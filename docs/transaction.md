## Transaction
트랜잭션은 데이터베이스의 일관성, 무결성 및 신뢰성을 유지하기 위해 사용된다<br>
> ACID
>
- Atomicity (원자성): 모든 작업은 전체가 성공되거나 전체가 실패되어야 한다<br>
- Consistency (일관성): 트랜잭션 후 데이터는 일관성이 있어야 한다<br>
- Isolation (고립성): 트랜잭션은 서로를 간섭할 수 없다. 트랜잭션 작업 중 다른 트랜잭션은 변경 전의 데이터만 볼 수 있다
- Durability (지속성): 트랜잭션이 완료되면 데이터는 영구적으로 저장되어야 한다

여기서 격리성을 지키기 위해서는 모든 처리가 동기화되어야 한다<br>
하지만 이는 성능을 저하시키므로 ANSI 표준은 트랜잭션의 격리 수준을 4단계로 정의한다<br>
> 격리수준 Isolation level
- DEFAULT: 데이터베이스 벤더의 기본 격리 수준
- READ_UNCOMMITTED: 가장 낮은 격리 수준으로, 커밋되지 않은 변경 사항을 다른 트랜잭션에서 읽을 수 있다
- READ_COMMITTED: 커밋된 데이터만 읽을 수 있다
- REPEATABLE_READ: 트랜잭션 내에서 읽은 데이터는 변경되지 않는다
- SERIALIZABLE: 가장 높은 격리 수준으로, 완전한 일관성을 보장하지만 성능이 떨어질 수 있다

>DB 요청 흐름<br>
>
클라이언트가 요청을 하면 WAS는 DB server 커넥션을 만들고 요청을 보낸다<br>
DB server는 내부에 세션을 생성하고 세션은 트랜잭션을 시작한다<br>
세션은 커넥션과 1:1로 생성된다<br>

- @Transactional(readOnly = true)<br>
  읽기 전용 트랜잭션으로 많은 데이터베이스가 최적화되어 있어 성능이 향상될 수 있다<br>
  SELECT요청만 가능하지만 DB에 따라 다를 수 있다
  <br><br>
- 수동 커밋 모드
```sql
set autocommit false;
-- sql ... 트랜잭션 내부
commit; -- commit 하기전에 rollback 가능
```


### Transaction 문제

> 목적<br>
> 
서비스 계층을 별도로 분리하여 순수한 자바 코드로 코드로 로직을 작성한다<br>
ㄴ 기술을 변경하여도 최대한 코드 수정을 피할 수 있게된다.

구현 기술이 변경되어도 서비스 로직은 최대한 변경하지 않아야 한다<br>
ㄴ 데이터 접근 계층에 JDBC 코드를 몰아 넣는다. 변경에 대처하기 위해 인터페이스를 의존한다

> 문제<br>



트랜잭션을 사용하게 되면 결국 서비스 계층에 JDBC 기술을 사용하게 된다<br>
ㄴ 기술이 변경되면 코드를 수정해야 한다

데이터 접근 계층의 JDBC 예외가 서비스 계층으로 전파된다<br>
ㄴ JDBC 예외이므로 기술을 변경하면 코드를 수정해야 한다

예외 처리 보일러플레이트 코드 문제

스프링을 사용하여 이러한 문제를 해결한다

[Back to main README](../README.md)